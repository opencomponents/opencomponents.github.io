"use strict";(self.webpackChunkoc_website=self.webpackChunkoc_website||[]).push([[4823],{6484:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"consumers/batch-endpoint","title":"Batch Endpoint","description":"It allows to retrieve a set of components with a single request to the API. While this should be convenient during the server-side rendering, it is not a good practice for client-side rendering.","source":"@site/docs/consumers/batch-endpoint.md","sourceDirName":"consumers","slug":"/consumers/batch-endpoint","permalink":"/docs/consumers/batch-endpoint","draft":false,"unlisted":false,"editUrl":"https://github.com/opencomponents/opencomponents.github.io/tree/master/website/docs/consumers/batch-endpoint.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Server-side Rendering","permalink":"/docs/consumers/server-side-rendering"},"next":{"title":"Publishing to a registry","permalink":"/docs/components/publishing-to-a-registry"}}');var r=t(4848),s=t(8453);const a={sidebar_position:7},i="Batch Endpoint",c={},l=[{value:"Server-side rendering via REST API using the POST route",id:"server-side-rendering-via-rest-api-using-the-post-route",level:2},{value:"Caching Strategies",id:"caching-strategies",level:3},{value:"Error Handling for Batch Operations",id:"error-handling-for-batch-operations",level:2},{value:"Partial Failure Handling",id:"partial-failure-handling",level:3},{value:"Retry Logic",id:"retry-logic",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"E-commerce Page",id:"e-commerce-page",level:3},{value:"Dashboard Layout",id:"dashboard-layout",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"batch-endpoint",children:"Batch Endpoint"})}),"\n",(0,r.jsx)(n.p,{children:"It allows to retrieve a set of components with a single request to the API. While this should be convenient during the server-side rendering, it is not a good practice for client-side rendering."}),"\n",(0,r.jsx)(n.h2,{id:"server-side-rendering-via-rest-api-using-the-post-route",children:"Server-side rendering via REST API using the POST route"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl http://my-components-registry.mydomain.com/ \\\n  -X POST \\\n  -H "Content-Type: application/json" \\\n  -d \'{"components":[{"name": "hello-world", "version": "1.X.X"}, {"name": "my-component", "parameters": { "something": 2345 }}]}\'\n'})}),"\n",(0,r.jsx)(n.p,{children:"Response:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'[{\n  "status": 200,\n  "response": {\n    "href": "https://my-components-registry.mydomain.com/hello-world/1.X.X",\n    "name": "hello-world",\n    "version": "1.0.0",\n    "requestVersion": "1.X.X",\n    "html": "Hello John doe!",\n    "type": "oc-component",\n    "renderMode": "rendered"\n  }\n},{\n  "status": 200,\n  "response": {\n    "href": "https://my-components-registry.mydomain.com/my-component/?something=2345",\n    "name": "my-component",\n    "version": "1.0.0",\n    "requestVersion": "",\n    "html": "Bla bla",\n    "type": "oc-component",\n    "renderMode": "rendered"\n  }\n}]\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\n## Payload API\n\n| Parameter                    | Type               | Mandatory | Description                                                                                                          |\n| ---------------------------- | ------------------ | --------- | -------------------------------------------------------------------------------------------------------------------- |\n| components                   | `array of objects` | `yes`     | Components to retrieve                                                                                               |\n| components[index].name       | `string`           | `yes`     | Component name                                                                                                       |\n| components[index].version    | `string`           | `no`      | Default latest, the component's version                                                                              |\n| components[index].parameters | `object`           | `no`      | Component's parameters                                                                                               |\n| omitHref                     | `boolean`          | `no`      | Default false, when `true` omits the href value in the response of each component                                    |\n| parameters                   | `object`           | `no`      | Global parameters for all components to retrieve. When component has its own parameters, globals will be overwritten |\n\n## Performance Optimization\n\n### When to Use Batch vs Individual Requests\n\n**Use Batch Endpoint When:**\n- Rendering multiple components on the same page\n- Components are needed simultaneously\n- Network latency is a concern\n- You want to reduce HTTP overhead\n\n**Use Individual Requests When:**\n- Loading components asynchronously\n- Implementing lazy loading\n- Components have different caching requirements\n- You need fine-grained error handling\n\n### Optimal Batch Size\n\n```js\n// Recommended: 5-10 components per batch\nconst componentBatches = chunkArray(allComponents, 8);\n\nfor (const batch of componentBatches) {\n  const results = await fetchBatch(batch);\n  renderComponents(results);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Cache batch responses by component combination\nconst cacheKey = components.map(c => `${c.name}:${c.version}`).join(',');\n\nif (cache.has(cacheKey)) {\n  return cache.get(cacheKey);\n}\n\nconst result = await fetchBatch(components);\ncache.set(cacheKey, result, { ttl: 300 }); // 5 minutes\nreturn result;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling-for-batch-operations",children:"Error Handling for Batch Operations"}),"\n",(0,r.jsx)(n.h3,{id:"partial-failure-handling",children:"Partial Failure Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async function renderBatchWithFallbacks(components) {\n  try {\n    const results = await fetchBatch(components);\n    \n    return results.map((result, index) => {\n      if (result.status !== 200) {\n        console.warn(`Component ${components[index].name} failed:`, result);\n        return {\n          status: 200,\n          response: {\n            html: getFallbackContent(components[index].name),\n            name: components[index].name\n          }\n        };\n      }\n      return result;\n    });\n  } catch (error) {\n    console.error('Batch request failed:', error);\n    return components.map(comp => ({\n      status: 500,\n      response: { html: getFallbackContent(comp.name), name: comp.name }\n    }));\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"retry-logic",children:"Retry Logic"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async function fetchBatchWithRetry(components, maxRetries = 3) {\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await fetchBatch(components);\n    } catch (error) {\n      if (attempt === maxRetries) throw error;\n      \n      const delay = Math.pow(2, attempt) * 1000; // Exponential backoff\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,r.jsx)(n.h3,{id:"e-commerce-page",children:"E-commerce Page"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Fetch all components for a product page\nconst productPageComponents = await fetchBatch([\n  { name: 'header', parameters: { user: currentUser } },\n  { name: 'product-details', parameters: { productId: '123' } },\n  { name: 'recommendations', parameters: { userId: currentUser.id } },\n  { name: 'reviews', parameters: { productId: '123', limit: 5 } },\n  { name: 'footer' }\n]);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dashboard-layout",children:"Dashboard Layout"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Load dashboard widgets in batches\nconst dashboardWidgets = await fetchBatch([\n  { name: 'analytics-widget', parameters: { timeframe: 'week' } },\n  { name: 'sales-widget', parameters: { region: 'US' } },\n  { name: 'inventory-widget' },\n  { name: 'notifications-widget', parameters: { userId: user.id } }\n]);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const startTime = Date.now();\n\nconst components = await fetchBatch(componentList);\n\nconst endTime = Date.now();\nconsole.log(`Batch request completed in ${endTime - startTime}ms`);\n\n// Log individual component performance\ncomponents.forEach((comp, index) => {\n  if (comp.status !== 200) {\n    console.error(`Component ${componentList[index].name} failed`);\n  }\n});\n"})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const r={},s=o.createContext(r);function a(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);